#!/usr/bin/env bash
# SPDX-License-Identifier: WTFPL

## Category: Various
## Shortdesc: Recursively unpack containers. That is, if there are other container files inside they will also be unpacked.

#%unwrap Unwrap is a Unpack Wrapper version 1.1
#%
#%Recursively unpack containers. That is, if there are other container files inside they will also be unpacked.
#%Supported container formats (package requirements apply)
#%- 3mf -> requires 'unzip'
#%- zipfiles (.zip) -> requires 'unzip'
#%- gzipped and pure tarballs (.tar, .tgz, .tar.gz) -> requires 'tar'
#%- xz packed tarballs (.tar.xz) -> requires 'tar' and 'xz'
#%- jar files -> requires 'unzip'
#%- war files -> requires 'unzip'
#%- ear files -> requires 'unzip'
#%- rar archives -> requires 'unrar'
#%- 7z archives -> requires '7z'
#%- rpm packages -> requires 'rpm2tar' and 'tar'
#%- deb packages -> requires 'dpkg-deb'
#%- iso images -> requires '7z'
#%- ipa images -> requires 'unzip'
#%- docx files -> requires 'unzip'
#%- cpio files -> requires 'cpio'
#%- apk files -> requires 'unzip'
#%- xapk files -> requires 'unzip'
#%
#%Usage: unwrap [-C <destdir>] [-v] [-x] [-h] <container_1> <container_2> ... <container_n>
#%
#%Available command line switches:
#%-C <destdir>  - unwrap to directory <destdir> instead of the current directory
#%-v            - increase verbosity
#%-H <hashfile> - store SHA256 hashes of all extracted files into <hashfile>
#%-x            - remove container after extraction
#%-G            - use file(1) and simple suffix detection logic to try and guess the container format
#%-o            - unwrap once, leave containers inside containers
#%-h            - this help text
#%
#%Author: Maciej Grela <enki@fsck.pl>

# Reference: https://stackoverflow.com/a/17841619
function join_by { local IFS="$1"; shift; echo "$*"; }

#
# log4bash
#
log() { echo $* 1>&2; }
error() { log $*; }
verbose() { [ -n "$verbose" ] && log $*; }
fatal() { log $*; exit 1; }

destdir=.

while getopts C:vxohGH: opt; do
    case $opt in
        C) destdir="$OPTARG";;
        v) verbose=1;;
        x) remove_container=1;;
        G) guess=1;;
        H) hash_filename="$OPTARG";;
        o) unwrap_once=1;;
        h) grep "^#%" $0 | sed 's/^#%//';;
        ?) exit 1;;
    esac
done
shift $((OPTIND-1))


detect_suffix() {
    container="$1"; shift;

    if [ -n "$guess" ]; then
        suffix="${container##*.}"

        #
        # Handle common problems with the above simplistic approach
        #
        [ -z "$suffix" ] && suffix='<unknown>'
        [ ".$suffix" = "$container" ] && suffix='<unknown>'

        if [ "$suffix" != '<unknown>' ]; then
            suffix=".$suffix"
            verbose "$container: guessed suffix '$suffix'"
        fi
    else
        suffix='<unknown>'
    fi

    case "$container" in
        *.3mf) suffix=".3mf";;
        *.zip) suffix=".zip";;
        *.jar) suffix=".jar";;
        *.war) suffix=".war";;
        *.ear) suffix=".ear";;
        *.apk) suffix=".apk";;
        *.xapk) suffix=".xapk";;
        *.ipa) suffix=".ipa";;
        *.docx) suffix=".docx";;
        *.tar) suffix=".tar";;
        *.tar.gz) suffix=".tar.gz";;
        *.tar.bz2) suffix=".tar.bz2";;
        *.tar.xz) suffix=".tar.xz";;
        *.tgz) suffix=".tgz";;
        *.tbz2) suffix=".tbz2";;
        *.rar) suffix=".rar";;
        *.7z) suffix='.7z';;
        *.rpm) suffix='.rpm';;
        *.deb) suffix='.deb';;
        *.udeb) suffix='.udeb';;
        *.iso) suffix='.iso';;
        *.cpio) suffix='.cpio';;
    esac

    echo $suffix
}


detect_container() {
    container="$1"; shift

    typecode='<unknown>'
    declare -a flags
    # This is needed due to how the bash 'read' function works
    # Without it the first word of unpack_cmd is eaten as the value of flags
    flags=('__placeholder_flag=1')

    suffix=$(detect_suffix "$container")
    if [ -n "$guess" ]; then
        mimetype=$(file --mime-type --brief "$container")
        verbose "$container: mime type '$mimetype'"
        case "$mimetype" in
            application/zip) typecode=zip;;
            application/x-tar) typecode=tar;;
        esac

        [ "$typecode" != '<unknown>' ] && verbose "$container: guessed type '$typecode'"
    fi

    # Typecode not detected based on mime_type, try to match the suffix
    if [ "$typecode" = '<unknown>' -a "$suffix" != '<unknown>' ]; then
        # Assign typecode based on suffix
        case "$suffix" in
            .zip) typecode=zip;;
            .rar) typecode=rar;;
            .7z) typecode=7z;;
            .cpio) typecode=cpio;;
            .jar|.war|.ear) typecode=zip;;
            .apk|.xapk|.ipa) typecode=zip;;
            .docx) typecode=zip;;
            .tar|.tar.gz|.tar.bz2|.tar.xz|.tgz|.tbz2) typecode='tar'; flags+=('auto_compress=1');;
            .rpm) typecode=rpm;;
            .deb|.udeb) typecode=dpkg;;
            .iso) typecode=iso;;
            .3mf) typecode=zip;;
            *)  # This file is not an container we know, skip
                error "$container: Skipping, not an container type we know"
                ;;
        esac
    fi

    # Assign variables based on typecode
    case "$typecode" in
        zip) unpack_cmd='[ -z "$verbose" ] && unzip_quiet_flag="-q"; unzip ${unzip_quiet_flag} -d "$unwrap_dir" "$container"';;
        tar) unpack_cmd='tar -C "$unwrap_dir" ${auto_compress:+--auto-compress} -x${verbose:+v}f "$container"';;
        rar) unpack_cmd='[ -z "$verbose" ] && unrar_quiet_flag="-inul"; unrar $unrar_quiet_flag x "$container" "$unwrap_dir/"';;
        7z) unpack_cmd='if [ -z "$verbose" ]; then 7z x -o"$unwrap_dir" "$container" > /dev/null; else 7z x -o"$unwrap_dir" "$container"; fi';;
        rpm) unpack_cmd='rpm2tar -O "$container" | tar -C "$unwrap_dir" -x${verbose:+v}';;
        dpkg) unpack_cmd='dpkg-deb -x "$container"  "$unwrap_dir"';;
        iso) unpack_cmd='if [ -z "$verbose" ]; then 7z x -o"$unwrap_dir" "$container" > /dev/null; else 7z x -o"$unwrap_dir" "$container"; fi';;
        cpio) unpack_cmd='cpio -id${verbose:+}v "$unwrap_dir" < "$container"';;
    esac

    echo "$typecode $suffix $(join_by , $flags) $unpack_cmd"
}


while [ "$1" ]; do
    container="$1"; shift

    if [ -n "$hash_filename" ]; then
        verbose "$container: Calculating SHA256 hash"
        sha256sum "$container" >> "$hash_filename"
    fi

    detect_container "$container" | ( read typecode suffix flags unpack_cmd

        if [ "$typecode" != '<unknown>' -a "$suffix" != '<unknown>' ]; then
            if [ -n "$flags" ]; then
                set -o allexport
                . <(echo $flags | sed 's/,/\n/')
                set +o allexport
            fi

            container_dir="$(basename "$container" "$suffix")"
            unwrap_dir="$destdir/$container_dir"
            verbose "$container: Unwrapping files into '$unwrap_dir' using command '$unpack_cmd'"
            mkdir -p "$unwrap_dir" && unwrap_dir=$unwrap_dir container=$container eval $unpack_cmd || error "$container: failed unpack_cmd '$unpack_cmd'"

            # Check for asdf.zip containing asdf/ which gets unwrapped into asdf/asdf/
            if find "$unwrap_dir" -maxdepth 1 -mindepth 1 -type d -name "$container_dir" | grep -q "$container_dir/$container_dir"; then
                # Remove unneeded directory
                ( shopt -s dotglob; mv "$unwrap_dir/$container_dir"/* "$unwrap_dir/" )
                rmdir "$unwrap_dir/$container_dir" || fatal "Someting is very wrong, '$unwrap_dir/$container_dir' should be empty"
            fi

            # Search for other containers inside the extracted container
            [ "$unwrap_once" ] || find "$unwrap_dir" -type f | while read file; do
                    detect_container "$file" | ( read typecode suffix flags unpack_cmd
                        if [ "$typecode" != '<unknown>' -a "$suffix" != '<unknown>' ]; then
                            container_dir=$(dirname "$file")
		                    unwrap -C "$container_dir" ${verbose:+-v} ${remove_container:+-x} ${guess:+-G} ${use_mimetype:+-m} ${hash_filename:+-H "$hash_filename"} "$file"
                        else
                            if [ -n "$hash_filename" ]; then
                                verbose "$file: Calculating SHA256 hash"
                                sha256sum "$file" >> "$hash_filename"
                            fi
                        fi
                    )
            done

            [ "$remove_container" ] && rm "$container"

        else
            error "$container: skipping, not a container type we know"
        fi
    )
done
